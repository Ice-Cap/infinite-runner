# Infinite Runner
#### Video Demo: https://youtu.be/wcskPYecN2o?si=fVt2hcUh576uls5o
#### Description:
To get started:
- Open command line and navigate to the game's directory
- Install dependencies: pip install -r requirements.txt
- Run the game: python3 main.py

This is an "infinite runner" game made with Python and Pygame for the final project of cs50. It can be run with the command: python3 main.py from the command line while in the game's directory. When the game is started, the player is presented with a screen that instructs the player to press SPACE to begin the game. Upon starting the game, the player character starts running and obstacles begin to appear at random intervals. The player can jump with space and move left or right with the left and right arrow keys. The player can move while in air as well. This can be helpful to avoid obstacles. When the player avoids an obstacle and the obstacle is no longer on screen, the points will be incremented by 1. With every point, the game speed is increased by 0.05 pixels per frame. This means that the obstacles will move 0.05 pixels faster to the left of the screen with every subsequent point the player receives. If the player character collides with an obstacle at any time, game over is initiated and the game over screen is shown which displays "Game Over" and the player's score for the round. If the player presses SPACE again, the game will restart.

The project is broken up into five different Python files and an assets folder. The main.py file imports the classes from the other files, loads images from the assets folder, initializes the global variables, initializes pygame, instantiates the game objects and sprite groups, and starts the game loop, which is set to run at 60 frames per second. While the game hasn't started yet, the game_start_screen() function is called for every frame until the player hits space, after which the game object's property "start" is updated to be True and the loop will begin generating obstacles, the player, and update the screen accordingly for each frame of the game. When the player collides with an obstacle, all sprites are removed, the game object's property "over" is set to True and "start" is set to False. The game loop will then call the game_over_screen() function for each frame until the player presses SPACE, which will then restart the game.

The Player.py file declares a class that extends the pygame Sprite class and creates a player object upon instantiation. A settings object and game object are passed into the constructor of the player class when it's instantiated so that it can have access to the global game variables and settings for how to create the player. In the constructor, the player class initializes the sprite frames that are used to animate the character, the first frame, initial player position, acceleration, velocity, and a boolean that is used to determine whether the player is currently jumping or not. The player class contains methods to move, check when the player touches the ground after jumping, jump, cancel jump (which allows the player to have jumps of different heights depending on how long the SPACE key is pressed), and animate.

The Ground.py file declares a class that extends the pygame Sprite class and creates the ground object. The ground object is a transparent rectangle that's the width of the screen and as tall as the ground in the background image so as to create the illusion that the player and obstacles are on the ground.

The Obstacle.py file declares a class that extends the pygame Sprite class and creates a random obstacle. There are three different rock types which are rendered at ground height. And there is a vine obstacles that's rendered at the top of the screen. The type of obstacle is determined in the constructor of the class. Vines have a 20% chance of appearing. If the obstacle is not a vine, a random rock sprite is chosen with the random.choice method. This class contains methods to update and move. The move method moves the obstacle to the left based on the game speed. If the obstacle is moved off screen, the speed is incremented by 0.05 and the score is incremented by 1. The obstacle is then removed from all sprite groups with the kill() method, which is inherited from the pygame Sprite class.

The TextHelper.py file declares a class that's used to help render text to the screen. I wrote this class to utilize a fluent interface so that the methods can be chained while creating text. The draw method sets the text that should be rendered. The background method sets the background color. The center method sets a boolean for if the text should be centered or not. The set_cords method sets the x and y coordinates where the text should be rendered. The set_offset method allows the caller to set an offset amount of pixels from center. And the render method is used to create and render the text to the screen based on the settings.